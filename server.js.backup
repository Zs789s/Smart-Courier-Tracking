const express = require('express');
const path = require('path');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const fs = require('fs').promises;
const { nanoid } = require('nanoid');

const PORT = process.env.PORT || 5000;
const SECRET = process.env.JWT_SECRET || 'dev-secret-key';

const app = express();
app.use(cors());
app.use(express.json());

// Simple JSON file-based DB (replacement for lowdb to avoid package export issues)
const DB_FILE = path.join(__dirname, 'db.json');
let db = { users: [], orders: [] };

async function readDB() {
  try {
    const txt = await fs.readFile(DB_FILE, 'utf8');
    const data = JSON.parse(txt || '{}');
    data.users = Array.isArray(data.users) ? data.users : [];
    data.orders = Array.isArray(data.orders) ? data.orders : [];
    return data;
  } catch (e) {
    return { users: [], orders: [] };
  }
}

async function writeDB(data) {
  await fs.writeFile(DB_FILE, JSON.stringify(data, null, 2), 'utf8');
}

async function initDB() {
  db = await readDB();
  await writeDB(db);
}

initDB();

// Serve static frontend
app.use(express.static(path.join(__dirname)));

// Helpers
function formatOrder(o) {
  return {
    id: o.id,
    tracking_number: o.tracking_number,
    trackingNumber: o.tracking_number,
    carrier: o.carrier,
    service: o.service,
    weight: o.weight,
    status: o.status,
    location: o.location,
    latitude: o.latitude,
    longitude: o.longitude,
    estimated_delivery: o.estimated_delivery,
    history: o.history || []
  };
}

// Routes
app.get('/api/track/:tracking_number', async (req, res) => {
  db = await readDB();
  const tn = req.params.tracking_number;
  const order = db.orders.find(o => o.tracking_number === tn);
  if (!order) return res.status(404).json({ message: 'Order not found' });
  return res.json(formatOrder(order));
});

// Search orders by phone number (sender or receiver). Returns array of matching orders.
app.get('/api/track/phone/:phone', async (req, res) => {
  db = await readDB();
  const raw = req.params.phone || '';
  const q = String(raw).replace(/\D/g, ''); // digits only
  if (!q) return res.status(400).json({ message: 'Invalid phone number' });

  const matches = db.orders.filter(o => {
    const sp = String(o.sender_phone || o.senderPhone || '') .replace(/\D/g, '');
    const rp = String(o.receiver_phone || o.receiverPhone || '') .replace(/\D/g, '');
    return (sp && sp.includes(q)) || (rp && rp.includes(q));
  });

  const results = matches.map(formatOrder);
  return res.json({ orders: results });
});

app.get('/api/orders', async (req, res) => {
  db = await readDB();
  return res.json({ orders: db.orders.map(formatOrder) });
});

app.post('/api/orders', async (req, res) => {
  db = await readDB();
  const data = req.body || {};
  const nextId = db.orders.length ? Math.max(...db.orders.map(o => o.id)) + 1 : 1;
  const tracking_number = data.tracking_number || ('SCS' + (10000 + nextId));
  const order = {
    id: nextId,
    tracking_number,
    // include optional fields sent by clients
    trackingNumber: tracking_number,
    sender_name: data.sender_name || data.senderName || '',
    sender_address: data.sender_address || data.senderAddress || '',
    sender_phone: data.sender_phone || data.senderPhone || '',
    receiver_name: data.receiver_name || data.receiverName || '',
    receiver_address: data.receiver_address || data.receiverAddress || '',
    receiver_phone: data.receiver_phone || data.receiverPhone || '',
    parcel_description: data.parcel_description || data.parcelDescription || '',
    value: data.value || data.estimated_value || 0,
    special_instructions: data.special_instructions || data.specialInstructions || '',
    carrier: data.carrier || 'SCS Logistics',
    service: data.service || 'Standard',
    weight: data.weight || 0,
    status: data.status || 'Pending',
    location: data.location || 'Order Placed',
    latitude: data.latitude || 0,
    longitude: data.longitude || 0,
    estimated_delivery: data.estimated_delivery || 'To be determined',
    history: data.history || [{ status: 'Order Placed', location: data.location || 'Customer Request', date: new Date().toISOString().slice(0,10) }]
  };
  db.orders.push(order);
  await writeDB(db);
  // Return the created order and both tracking_number and trackingNumber for client compatibility
  res.status(201).json({
    message: 'Order created successfully',
    tracking_number: order.tracking_number,
    trackingNumber: order.tracking_number,
    order: formatOrder(order)
  });
});

app.delete('/api/orders/:id', async (req, res) => {
  db = await readDB();
  const id = Number(req.params.id);
  const idx = db.orders.findIndex(o => o.id === id);
  if (idx === -1) return res.status(404).json({ message: 'Order not found' });
  db.orders.splice(idx, 1);
  await writeDB(db);
  res.json({ message: 'Order deleted successfully' });
});

app.put('/api/orders/:id', async (req, res) => {
  db = await readDB();
  const id = Number(req.params.id);
  const order = db.orders.find(o => o.id === id);
  if (!order) return res.status(404).json({ message: 'Order not found' });
  const fields = ['status','location','latitude','longitude','estimated_delivery','carrier','service','weight','history'];
  fields.forEach(f => {
    if (req.body[f] !== undefined) order[f] = req.body[f];
  });
  await writeDB(db);
  res.json({ message: 'Order updated successfully', order: formatOrder(order) });
});

// Users
app.get('/api/users', async (req, res) => {
  db = await readDB();
  const users = db.users.map(u => ({ id: u.id, username: u.username, email: u.email }));
  res.json({ users });
});

app.delete('/api/users/:id', async (req, res) => {
  db = await readDB();
  const id = Number(req.params.id);
  const idx = db.users.findIndex(u => u.id === id);
  if (idx === -1) return res.status(404).json({ message: 'User not found' });
  db.users.splice(idx,1);
  await writeDB(db);
  res.json({ message: 'User deleted successfully' });
});

app.post('/api/register', async (req, res) => {
  db = await readDB();
  const { username, email, password } = req.body || {};
  if (!username || !email || !password) return res.status(400).json({ message: 'Missing required fields' });
  if (db.users.find(u => u.username === username)) return res.status(400).json({ message: 'Username already exists' });
  if (db.users.find(u => u.email === email)) return res.status(400).json({ message: 'Email already exists' });
  const id = db.users.length ? Math.max(...db.users.map(u => u.id)) + 1 : 1;
  const password_hash = await bcrypt.hash(password, 10);
  db.users.push({ id, username, email, password_hash });
  await writeDB(db);
  res.status(201).json({ message: 'User created successfully' });
});

app.post('/api/login', async (req, res) => {
  db = await readDB();
  const { username, password } = req.body || {};
  if (!username || !password) return res.status(400).json({ message: 'Missing username or password' });
  const user = db.users.find(u => u.username === username);
  if (!user) return res.status(401).json({ message: 'Invalid username or password' });
  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) return res.status(401).json({ message: 'Invalid username or password' });
  const token = jwt.sign({ user_id: user.id }, SECRET, { expiresIn: '1d' });
  res.json({ message: 'Login successful', token, username: user.username });
});

// Fallback to serve index.html for other routes (SPA behavior)
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
